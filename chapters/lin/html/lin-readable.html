<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="description" content="Solving linear systems">

<title>Solving linear systems</title>

<!-- Bootstrap style: bootswatch_readable -->
<link href="https://netdna.bootstrapcdn.com/bootswatch/3.1.1/readable/bootstrap.min.css" rel="stylesheet">
<!-- not necessary
<link href="https://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
-->

<style type="text/css">
/* Let inline verbatim have the same color as the surroundings */
code { color: inherit; background-color: transparent; }

/* Add scrollbar to dropdown menus in bootstrap navigation bar */
.dropdown-menu {
   height: auto;
   max-height: 400px;
   overflow-x: hidden;
}

/* Adds an invisible element before each target to offset for the navigation
   bar */
.anchor::before {
  content:"";
  display:block;
  height:64px;      /* fixed header height for style bootswatch_readable */
  margin:-64px 0 0; /* negative fixed header height */
}
</style>


</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [('Table of contents',
               1,
               'table_of_contents',
               'table_of_contents'),
              ('Solving linear equations', 1, None, '___sec0'),
              ('Gauss-Jordan elimination', 2, None, '___sec1'),
              ('Pivoting', 2, None, '___sec2'),
              ('LU decomposition', 2, None, '___sec3'),
              ('Iterative methods', 1, None, '___sec4'),
              ('Iterative improvement', 2, None, '___sec5'),
              ('The Jacobi method', 2, None, '___sec6'),
              ('The Gauss-Seidel method', 2, None, '___sec7'),
              ('Example: Linear regression', 1, None, '___sec8'),
              ('Solving least square, using algebraic equations',
               2,
               None,
               '___sec9'),
              ('Least square as a linear algebra problem', 2, None, '___sec10'),
              ('Working with matrices on component form', 2, None, '___sec11'),
              ('Sparse matrices and Thomas algorithm', 1, None, '___sec12'),
              ('Example: Solving the heat equation using linear algebra',
               1,
               None,
               '___sec13'),
              ('Exercise 1: Conservation Equation or the Continuity Equation',
               2,
               None,
               '___sec14'),
              ('Exercise 2: Curing of Concrete and Matrix Formulation',
               2,
               None,
               '___sec15'),
              ('References', 1, None, '___sec16')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript" async
 src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\no}{\nonumber}
$$




    
<!-- Bootstrap navigation bar -->
<div class="navbar navbar-default navbar-fixed-top">
  <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="lin-readable.html">Solving linear systems</a>
  </div>

  <div class="navbar-collapse collapse navbar-responsive-collapse">
    <ul class="nav navbar-nav navbar-right">
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Contents <b class="caret"></b></a>
        <ul class="dropdown-menu">
     <!-- navigation toc: --> <li><a href="#table_of_contents" style="font-size: 80%;"><b>Table of contents</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec0" style="font-size: 80%;"><b>Solving linear equations</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Gauss-Jordan elimination</a></li>
     <!-- navigation toc: --> <li><a href="#___sec2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Pivoting</a></li>
     <!-- navigation toc: --> <li><a href="#___sec3" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;LU decomposition</a></li>
     <!-- navigation toc: --> <li><a href="#___sec4" style="font-size: 80%;"><b>Iterative methods</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec5" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Iterative improvement</a></li>
     <!-- navigation toc: --> <li><a href="#___sec6" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The Jacobi method</a></li>
     <!-- navigation toc: --> <li><a href="#___sec7" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The Gauss-Seidel method</a></li>
     <!-- navigation toc: --> <li><a href="#___sec8" style="font-size: 80%;"><b>Example: Linear regression</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec9" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Solving least square, using algebraic equations</a></li>
     <!-- navigation toc: --> <li><a href="#___sec10" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Least square as a linear algebra problem</a></li>
     <!-- navigation toc: --> <li><a href="#___sec11" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Working with matrices on component form</a></li>
     <!-- navigation toc: --> <li><a href="#___sec12" style="font-size: 80%;"><b>Sparse matrices and Thomas algorithm</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec13" style="font-size: 80%;"><b>Example: Solving the heat equation using linear algebra</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec14" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercise 1: Conservation Equation or the Continuity Equation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec15" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercise 2: Curing of Concrete and Matrix Formulation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec16" style="font-size: 80%;"><b>References</b></a></li>

        </ul>
      </li>
    </ul>
  </div>
</div>
</div> <!-- end of navigation bar -->

<div class="container">

<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p> <!-- add vertical space -->

<a name="part0000"></a>
<!-- ------------------- main content ---------------------- -->



<div class="jumbotron">
<center><h1>Solving linear systems </h1></center>  <!-- document title -->

<p>
<!-- author(s): Aksel Hiorth, the National IOR Centre &amp; Institute for Energy Resources, -->

<center>
<b>Aksel Hiorth, the National IOR Centre &amp; Institute for Energy Resources,</b> 
</center>

<p>
<!-- institution(s) -->

<br>
University of Stavanger
<p>
<center><h4>Sep 23, 2020</h4></center> <!-- date -->
<br>
<p>
</div> <!-- end jumbotron -->

<h1 id="table_of_contents">Table of contents</h2>

<p>
<a href="#___sec0"> Solving linear equations </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec1"> Gauss-Jordan elimination </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec2"> Pivoting </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec3"> LU decomposition </a><br>
<a href="#___sec4"> Iterative methods  </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec5"> Iterative improvement </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec6"> The Jacobi method </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec7"> The Gauss-Seidel method </a><br>
<a href="#___sec8"> Example: Linear regression </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec9"> Solving least square, using algebraic equations </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec10"> Least square as a linear algebra problem </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec11"> Working with matrices on component form </a><br>
<a href="#___sec12"> Sparse matrices and Thomas algorithm </a><br>
<a href="#___sec13"> Example: Solving the heat equation using linear algebra </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec14"> Exercise 1: Conservation Equation or the Continuity Equation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec15"> Exercise 2: Curing of Concrete and Matrix Formulation </a><br>
<a href="#___sec16"> References </a><br>
</p>
<p>
<!-- Common Mako variables and functions -->

<p>
Solving systems of equations are one of the most common tasks that we use computers for within modeling. A typical task is that we have a model that contains a set of unknown parameters which we want to determine. To determine these parameters we need to solve a set of equations. In many cases these equations are nonlinear, but often a nonlinear problem is solved
<em>by linearize</em> the nonlinear equations, and thereby reducing it to a sequence of linear algebra problems. Thus the topic of solving linear systems of equations have been extensively studied, and sophisticated linear equation solving packages have been developed. Python uses functions from the <a href="https://en.wikipedia.org/wiki/LAPACK" target="_self">LAPACK</a> library. In this course we will only cover the theory behind numerical linear algebra superficially, and the main purpose is to shed some light on some of the challenges one might encounter solving linear systems. In particular it is important for you to understand when it is stated in the NumPy documentation that the standard linear solver: <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.solve.html" target="_self"><tt>solve</tt></a> function uses <em>LU-decomposition</em> and <em>partial pivoting</em>.

<p>
<!-- After covering some basics of numerical linear algebra, we will shift focus to nonlinear equations. Contrary to linear equations, you will most likely find that the functions available in various Python library will <em>not</em> cover your needs and in many cases fail to give you the correct solution. The reason for this is that the solution of a nonlinear equation is greatly dependent on the starting point, and a combination of various techniques must be used. -->

<h1 id="___sec0" class="anchor">Solving linear equations </h1>
There are a number of excellent books covering this topic, see e.g. <a href="#press2007">[1]</a> <a href="#trefethen1997">[2]</a> <a href="#stoer2013">[3]</a> <a href="#strang2019">[4]</a>.
In most of the examples covered in this course we will encounter problems where we have a set of <em>linearly independent</em> equations and one equation for each unknown. For these type of problems there are a number of methods that can be used, and they will find a solution in a finite number of steps. If a solution cannot be found it is usually because the equations are not linearly independent, and our formulation of the physical problem is wrong.

<p>
Assume that we would like to solve the following set of equations:
$$
\begin{align}
2x_0+x_1+x_2+3x_3&=1,label{eq:lin:la} \\ 
x_0+x_1+3x_2+x_3&=-3,label{eq:lin:lb} \\ 
x_0+4x_1+x_2+x_3&=2,label{eq:lin:lc} \\ 
x_0+x_1+x_2+x_3&=1.label{eq:lin:ld} 
\end{align}
$$

These equations can be written in matrix form as:
$$
\begin{equation}
\mathbf{A\cdot x}=\mathbf{b},
\tag{1}
\end{equation}
$$

where:
$$
\begin{equation}
\mathbf{A}\equiv\begin{pmatrix}
2&1&1&3\\ 
1&1&3&1\\ 
1&4&1&1\\ 
1&1&2&2
\end{pmatrix}
\qquad
\mathbf{b}\equiv
\begin{pmatrix}
1\\-3\\2\\1
\end{pmatrix}
\qquad
\mathbf{x}\equiv
\begin{pmatrix}
x_0\\x_1\\x_2\\x_3
\end{pmatrix}.
\tag{2}
\end{equation}
$$

You can easily verify that \( x_0=-4, x_1=1, x_2=-1, x_3= 3 \) is the
solution to the above equations by direct substitution. If we were to
replace one of the above equations with a linear combination of any of
the other equations, e.g. replace equation \eqref{eq:lin:ld} with
\( 3x_0+2x_1+4x_2+4x_3=-2 \), there would be no unique solution (infinite
number of solutions). This can be checked by calculating the determinant of the matrix \( \mathbf{A} \), if \( \det \mathbf{A}=0  \),  
What is the difficulty in solving these equations? Clearly if none of the equations are linearly dependent, and we have \( N \) independent linear equations, it should be straight forward to solve them? Two major numerical problems are i) even if the equations are not exact linear combinations of each other, they could be very close, and as the numerical algorithm progresses they could at some stage become linearly dependent due to roundoff errors. ii) roundoff errors may accumulate if the number of equations are large <a href="#press2007">[1]</a>.

<h2 id="___sec1" class="anchor">Gauss-Jordan elimination </h2>
Let us continue the discussion by consider Gauss-Jordan elimination, which is a <em>direct</em> method. A direct method uses a final set of operations to obtain a solution. According to <a href="#press2007">[1]</a> Gauss-Jordan elimination is the method of choice if we want to find the inverse of \( \mathbf{A} \). However, it is slow when it comes to calculate the solution of equation
<a href="#mjx-eqn-1">(1)</a>. Even if speed and memory use is not an issue, it is also not advised to first find the inverse, \( \mathbf{A}^{-1} \), of \( \mathbf{A} \), then multiply it with \( \mathbf{b} \) to obtain the solution, due to roundoff errors (Roundoff errors occur whenever we subtract to numbers that are very close to each other). To simplify our notation, we write equation <a href="#mjx-eqn-2">(2)</a> as:
$$
\begin{equation}
\left(
\begin{array}{cccc|c}
2&1&1&3&1\\ 
1&1&3&1&-3\\ 
1&4&1&1&2\\ 
1&1&2&2&1
\end{array}
\right).
\tag{3}
\end{equation}
$$

The numbers to the left of the vertical dash is the matrix \( \mathbf{A} \), and to the right is the vector \( \mathbf{b} \). The Gauss-Jordan elimination procedure proceeds by doing the same operation on the right and left side of the dash, and the goal is to get only zeros on the lower triangular part of the matrix. This is achieved by multiplying rows with the same (nonzero) number, swapping rows, adding a multiple of a row to another:
$$
\begin{align}
&\left(
\begin{array}{cccc|c}
2&1&1&3&1\\ 
1&1&3&1&-3\\ 
1&4&1&1&2\\ 
1&1&2&2&1
\end{array}
\right)\to
\left(
\begin{array}{cccc|c}
2&1&1&3&1\\ 
0&1/2&5/2&-1/2&-7/2\\ 
0&7/2&1/2&-1/2&3/2\\ 
0&1/2&3/2&1/2&1/2
\end{array}
\right)\to\tag{4}\\ 
&\left(
\begin{array}{cccc|c}
2&1&1&3&1\\ 
0&1/2&5/2&-1/2&-7/2\\ 
0&0&-17&3&26\\ 
0&0&1&-1&4
\end{array}
\right)
\to
\left(
\begin{array}{cccc|c}
2&1&1&3&1\\ 
0&1/2&5/2&-1/2&-7/2\\ 
0&0&-17&3&26\\ 
0&0&0&14/17&42/17
\end{array}
\right)\no
\end{align}$$

The operations done are: (\( 1\to2 \)) multiply first row with \( -1/2 \) and add to second, third and the fourth row, (\( 2\to 3 \)) multiply second row with \( -7 \), and add to third row, multiply second row with \( -1 \) and add to fourth row, (\( 3\to4 \)) multiply third row with \( -1/17 \) and add to fourth row. These operations can easily be coded into Python:
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>A <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array([[<span style="color: #666666">2</span>, <span style="color: #666666">1</span>, <span style="color: #666666">1</span>, <span style="color: #666666">3</span>,],[<span style="color: #666666">1</span>, <span style="color: #666666">1</span>, <span style="color: #666666">3</span>, <span style="color: #666666">1</span>],
              [<span style="color: #666666">1</span>, <span style="color: #666666">4</span>, <span style="color: #666666">1</span>, <span style="color: #666666">1</span>, ],[<span style="color: #666666">1</span>, <span style="color: #666666">1</span>, <span style="color: #666666">2</span>, <span style="color: #666666">2</span> ]],<span style="color: #008000">float</span>)
b <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array([<span style="color: #666666">1</span>,<span style="color: #666666">-3</span>,<span style="color: #666666">2</span>,<span style="color: #666666">1</span>],<span style="color: #008000">float</span>)
N<span style="color: #666666">=4</span>
<span style="color: #408080; font-style: italic"># Gauss-Jordan Elimination</span>
<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>,N):
    fact    <span style="color: #666666">=</span> A[i:,i<span style="color: #666666">-1</span>]<span style="color: #666666">/</span>A[i<span style="color: #666666">-1</span>,i<span style="color: #666666">-1</span>]
    A[i:,] <span style="color: #666666">-=</span> np<span style="color: #666666">.</span>outer(fact,A[i<span style="color: #666666">-1</span>,])
    b[i:]  <span style="color: #666666">-=</span> b[i<span style="color: #666666">-1</span>]<span style="color: #666666">*</span>fact
</pre></div>
<p>
Notice that the final matrix has only zeros beyond the diagonal, such a matrix is called <em>upper triangular</em>. We still have not found the final solution, but from an upper triangular (or lower triangular) matrix it is trivial to determine the solution. The last row immediately gives us \( 14/17z=42/17 \) or \( z=3 \), now we have the solution for z and the next row gives: \( -17y+3z=26 \) or \( y=(26-3\cdot3)/(-17)=-1 \), and so on. In a more general form, we can write our solution of the matrix \( \mathbf{A} \) after making it upper triangular as:
$$
\begin{equation}
\begin{pmatrix}
a^\prime_{0,0}&a^\prime_{0,1}&a^\prime_{0,2}&a^\prime_{0,3}\\ 
0&a^\prime_{1,1}&a^\prime_{1,2}&a^\prime_{1,3}\\ 
0&0&a^\prime_{2,2}&a^\prime_{2,3}\\ 
0&0&0&a^\prime_{3,3}
\end{pmatrix}
\cdot
\begin{pmatrix}
x_0\\ 
x_1\\ 
x_2\\ 
x_3
\end{pmatrix}
=
\begin{pmatrix}
b^\prime_{0}\\ 
b^\prime_{1}\\ 
b^\prime_{2}\\ 
b^\prime_{3}
\end{pmatrix}
\tag{5}
\end{equation}
$$

The backsubstitution can then be written formally as:
$$
\begin{equation}
x_i=\frac{1}{a^\prime_{ii}}\left[b_i^\prime-\sum_{j=i+1}^{N-1}a^\prime_{ij}x_j\right],\quad i=N-1,N-2,\ldots,0
\tag{6}
\end{equation}
$$

The backsubstitution can now easily be implemented in Python as:
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #408080; font-style: italic"># Backsubstitution</span>
sol <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(N,<span style="color: #008000">float</span>)
sol[N<span style="color: #666666">-1</span>]<span style="color: #666666">=</span>b[N<span style="color: #666666">-1</span>]<span style="color: #666666">/</span>A[N<span style="color: #666666">-1</span>,N<span style="color: #666666">-1</span>]
<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">2</span>,N<span style="color: #666666">+1</span>):
    sol[N<span style="color: #666666">-</span>i]<span style="color: #666666">=</span>(b[N<span style="color: #666666">-</span>i]<span style="color: #666666">-</span>np<span style="color: #666666">.</span>dot(A[(N<span style="color: #666666">-</span>i),],sol))<span style="color: #666666">/</span>A[N<span style="color: #666666">-</span>i,N<span style="color: #666666">-</span>i]
</pre></div>
<p>
Notice that in the Python implementation, we have used vector operations instead of for loops. This makes the code more efficient, but it could also be implemented with for loops: 
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #408080; font-style: italic"># Backsubstitution - for loop</span>
sol <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(N,<span style="color: #008000">float</span>)
<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N<span style="color: #666666">-1</span>,<span style="color: #666666">-1</span>,<span style="color: #666666">-1</span>):
    sol[i]<span style="color: #666666">=</span> b[i]
    <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(i<span style="color: #666666">+1</span>,N):
        sol[i] <span style="color: #666666">-=</span> A[i][j]<span style="color: #666666">*</span>sol[j]
    sol[i] <span style="color: #666666">/=</span> A[i][i]
</pre></div>
<p>
There are at least two things to notice with our implementation:

<ul>
<li> Matrix and vector notation makes the code more compact and efficient. In order to understand the implementation it is advised to put \( i=1, 2, 3, 4 \), and then execute the statements in the Gauss-Jordan elimination and compare with equation <a href="#mjx-eqn-4">(4)</a>.</li>
<li> The implementation of the Gauss-Jordan elimination is not robust, in particular one could easily imagine cases where one of the leading coefficients turned out as zero, and the routine would fail when we divide by <code>A[i-1,i-1]</code>. By simply changing equation \eqref{eq:lin:lb} to \( 2x_0+x_1+3x_2+x_3=-3 \), when doing the first Gauss-Jordan elimination, both \( x_0 \) and \( x_1 \) would be canceled. In the next iteration we try to divide next equation by the leading coefficient of \( x_1 \), which is zero, and the whole procedure fails.</li>
</ul>

<h2 id="___sec2" class="anchor">Pivoting </h2>
The solution to the last problem is solved by what is called <em>pivoting</em>. The element that we divide on is called the <em>pivot element</em>. It actually turns out that even if we do Gauss-Jordan elimination <em>without</em> encountering a zero pivot element, the Gauss-Jordan procedure is numerically unstable in the presence of roundoff errors <a href="#press2007">[1]</a>. There are two versions of pivoting, <em>full pivoting</em> and <em>partial pivoting</em>. In partial pivoting we only interchange rows, while in full pivoting we also interchange rows and columns. Partial pivoting is much easier to implement, and the algorithm is as follows:

<ol>
<li> Find the row in \( \mathbf{A} \) with largest absolute value in front of \( x_0 \) and change with the first equation, switch corresponding elements in \( \mathbf{b} \)</li>
<li> Do one Gauss-Jordan elimination, find the row in \( \mathbf{A} \) with the largest absolute value in front of \( x_1 \) and switch with the second (same for \( \mathbf{b} \)), and so on.</li>
</ol>

For a linear equation we can multiply with a number on each side and the equation would be unchanged, so if we where to multiply one of the equations with a large value, we are almost sure that this equation would be placed first by our algorithm. This seems a bit strange as our mathematical problem is the same. Sometimes the linear algebra routines tries to normalize the equations to find the pivot element that would have been the largest element if all equations were normalized according to some rule, this is called <em>implicit pivoting</em>.

<h2 id="___sec3" class="anchor">LU decomposition </h2>
As we have already seen, if the matrix \( \mathbf{A} \) is reduced to a triangular form it is trivial to calculate the solution by using backsubstitution. Thus if it was possible to decompose the matrix \( \mathbf{A} \) as follows:
$$
\begin{align}
&\mathbf{A}=\mathbf{L}\cdot\mathbf{U}label{eq:lin:lu}\\ 
&\begin{pmatrix}
a_{0,0}&a_{0,1}&a_{0,2}&a_{0,3}\\ 
a_{1,0}&a_{1,1}&a_{1,2}&a_{1,3}\\ 
a_{2,0}&a_{2,1}&a_{2,2}&a_{2,3}\\ 
a_{3,0}&a_{3,1}&a_{3,2}&a_{3,3}
\end{pmatrix}
=
\begin{pmatrix}
l_{0,0}&0&0&0\\ 
l_{1,0}&l_{1,1}&0&0\\ 
l_{2,0}&l_{2,1}&l_{2,2}&0\\ 
l_{3,0}&l_{3,1}&l_{3,2}&l_{3,3}
\end{pmatrix}
\cdot
\begin{pmatrix}
u_{0,0}&u_{0,1}&u_{0,2}&u_{0,3}\\ 
0&u_{1,1}&u_{1,2}&u_{1,3}\\ 
0&0&u_{2,2}&u_{2,3}\\ 
0&0&0&u_{3,3}
\end{pmatrix}.\no
\end{align}$$

The solution procedure would then be to rewrite equation <a href="#mjx-eqn-1">(1)</a> as:
$$
\begin{align}
\mathbf{A\cdot x}=\mathbf{L}\cdot\mathbf{U}\cdot\mathbf{x}=\mathbf{b},label{eq:lin:matb}
\end{align}
$$

If we define a new vector \( \mathbf{y} \):
$$
\begin{align}
\mathbf{y}\equiv\mathbf{U}\cdot\mathbf{x},
\tag{7}
\end{align}
$$

we can first solve for the \( \mathbf{y} \) vector:
$$
\begin{align}
\mathbf{L}\cdot\mathbf{y}=\mathbf{b},label{eq:lin:for}
\end{align}
$$

and then for \( \mathbf{x} \):
$$
\begin{align}
\mathbf{U}\cdot\mathbf{x}=\mathbf{y}.
\tag{8}
\end{align}
$$

Note that the solution to equation \eqref{eq:lin:for} would be done by <em>forward substitution</em>:
$$
\begin{equation}
y_i=\frac{1}{l_{ii}}\left[b_i-\sum_{j=0}^{i-1}l_{ij}x_j\right],\quad i=1,2,\ldots N-1.
\tag{9}
\end{equation}
$$

Why go to all this trouble? First of all it requires (slightly) less operations to calculate the LU decomposition and doing the forward and backward substitution than the Gauss-Jordan procedure discussed earlier. Secondly, and more importantly, is the fact that in many cases one would like to calculate the solution for different values of the \( \mathbf{b} \) vector in equation \eqref{eq:lin:matb}. If we do the LU decomposition first we can calculate the solution quite fast using backward and forward substitution for any value of the \( \mathbf{b} \) vector.

<p>
The NumPy function <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.solve.html" target="_self"><tt>solve</tt></a>, uses LU decomposition and partial pivoting, and we can find the solution to our previous problem simply by the following code:
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy.linalg</span> <span style="color: #008000; font-weight: bold">import</span> solve
x<span style="color: #666666">=</span>solve(A,b)
</pre></div>

<h1 id="___sec4" class="anchor">Iterative methods  </h1>
The methods described so far are what is called <em>direct</em> methods. The direct methods for very large systems might suffer from round off errors. That means that even if the computer has found a solution, the solution is "polluted" by round off errors, or stated more clearly: your solution for \( \mathbf{x} \), when entered into the original equation \( \mathbf{A}\mathbf{x}\neq\mathbf{b} \). Below we will describe one trick, and two alternative methods to the direct methods.

<h2 id="___sec5" class="anchor">Iterative improvement </h2>
The first method <a href="#press2001">[5]</a> assumes that we already have solved the matrix equation <a href="#mjx-eqn-1">(1)</a>, and obtained an <em>estimate</em> \( \mathbf{\hat{x}} \) of the true solution \( \mathbf{x} \). Assume that \( \mathbf{\hat{x}}=\mathbf{x}+\delta\mathbf{x} \), and that
$$
\begin{equation}
\mathbf{A}\cdot\mathbf{\hat{x}}=\mathbf{A}\cdot(\mathbf{x}+\delta\mathbf{x})=\mathbf{b}+\delta\mathbf{b},
\tag{10}
\end{equation}
$$

subtracting equation <a href="#mjx-eqn-1">(1)</a> we get
$$
\begin{equation}
\mathbf{A}\cdot\delta\mathbf{x}=\delta\mathbf{b}.
\tag{11}
\end{equation}
$$

Solving equation <a href="#mjx-eqn-10">(10)</a> for \( \delta\mathbf{b} \) an inserting in the equation above, we get
$$
\begin{equation}
\mathbf{A}\cdot\delta\mathbf{x}=\mathbf{A}\cdot\mathbf{\hat{x}}-\mathbf{b}.
\tag{12}
\end{equation}
$$

The usefulness of this method assumes that we have already obtained the LU decomposition of \( \mathbf{A} \), and if possible one should use a higher precision to calculate the right hand side, since there will be a lot of cancellations. Then the whole computational process it is simply to calculate the right hand side and backsubstitute. The improved solution is then obtained by subtracting \( \delta\mathbf{x} \) from \( \mathbf{\hat{x}} \).

<h2 id="___sec6" class="anchor">The Jacobi method </h2>
A completely different approach is the Jacobian method, which is simply to decompose the \( \mathbf{A} \) matrix in the following way
$$
\begin{align}
&\mathbf{A}=\mathbf{D}+\mathbf{R}label{eq:lin:DR}\\ 
&\begin{pmatrix}
a_{0,0}&a_{0,1}&a_{0,2}&a_{0,3}\\ 
a_{1,0}&a_{1,1}&a_{1,2}&a_{1,3}\\ 
a_{2,0}&a_{2,1}&a_{2,2}&a_{2,3}\\ 
a_{3,0}&a_{3,1}&a_{3,2}&a_{3,3}
\end{pmatrix}
=
\begin{pmatrix}
a_{0,0}&0&0&0\\ 
0&a_{1,1}&0&0\\ 
0&0&a_{2,2}&0\\ 
0&0&0&a_{3,3}
\end{pmatrix}
+
&\begin{pmatrix}
0&a_{0,1}&a_{0,2}&a_{0,3}\\ 
a_{1,0}&0&a_{1,2}&a_{1,3}\\ 
a_{2,0}&a_{2,1}&0&a_{2,3}\\ 
a_{3,0}&a_{3,1}&0&a_{3,3}
\end{pmatrix}.\no
\end{align}$$

We can then write equation <a href="#mjx-eqn-1">(1)</a> as
$$
\begin{equation}
\mathbf{D}\mathbf{x}=\mathbf{b}-\mathbf{R}\cdot\mathbf{x}.
\tag{13}
\end{equation}
$$

How does this help us? First of all, the matrix \( \mathbf{D} \) is easy to invert as it is diagonal, the inverse can be found by simply replace \( a_{ii}\to 1/a_{ii} \). But \( \mathbf{x} \) is still present on the right hand side? This is where the <em>iterations</em> comes into play, we simply guess at an initial solution \( \mathbf{x}^k \), and then we use equation <a href="#mjx-eqn-13">(13)</a> to calculate the next solution \( \mathbf{x}^{k+1} \), and so on
$$
\begin{equation}
\mathbf{x}^{k+1}=\mathbf{D}^{-1}(\mathbf{b}-\mathbf{R}\cdot\mathbf{x}^{k}).
\tag{14}
\end{equation}
$$

Lets write it out on component form for a \( 4\times4 \) matrix to see what is going on
$$
\begin{align}
x_0 &=\frac{1}{a_{00}}(b_0-a_{01}x_1^k-a_{02}x_2^k-a_{03}x_3^k),label{eq:lin:jc3a}\\ 
x_1 &=\frac{1}{a_{11}}(b_0-a_{00}x_0^k-a_{02}x_2^k-a_{03}x_3^k),label{eq:lin:jc3b}\\ 
x_2 &=\frac{1}{a_{22}}(b_0-a_{00}x_0^k-a_{01}x_1^k-a_{03}x_3^k),label{eq:lin:jc3c}\\ 
x_3 &=\frac{1}{a_{33}}(b_0-a_{00}x_0^k-a_{01}x_1^k-a_{02}x_2^k).label{eq:lin:jc3d}
\end{align}
$$

Below is a Python implementation
<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">solve_jacobi</span>(A,b,x<span style="color: #666666">=</span>np<span style="color: #666666">.</span>zeros(<span style="color: #008000">len</span>(b)),max_iter<span style="color: #666666">=1000</span>,EPS<span style="color: #666666">=1e-6</span>):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Solves the linear system Ax=b using the jacobi method, stops if</span>
<span style="color: #BA2121; font-style: italic">    solution is not found after max_iter or if solution changes less </span>
<span style="color: #BA2121; font-style: italic">    than EPS</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    D<span style="color: #666666">=</span>np<span style="color: #666666">.</span>diag(A)
    R<span style="color: #666666">=</span>A<span style="color: #666666">-</span>np<span style="color: #666666">.</span>diag(D)
    eps<span style="color: #666666">=1</span>
    x_old<span style="color: #666666">=</span>x
    <span style="color: #008000">iter</span><span style="color: #666666">=0</span>
    <span style="color: #008000; font-weight: bold">while</span>(eps<span style="color: #666666">&gt;</span>EPS <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #008000">iter</span><span style="color: #666666">&lt;</span>max_iter):
        <span style="color: #008000">iter</span><span style="color: #666666">+=1</span>
        x<span style="color: #666666">=</span>(b<span style="color: #666666">-</span>np<span style="color: #666666">.</span>dot(R,x_old))<span style="color: #666666">/</span>D
        eps<span style="color: #666666">=</span>np<span style="color: #666666">.</span>abs(np<span style="color: #666666">.</span>sum(x<span style="color: #666666">-</span>x_old))
        x_old<span style="color: #666666">=</span>x
    <span style="color: #008000">print</span>(<span style="color: #BA2121">&#39;found solution after &#39;</span> <span style="color: #666666">+</span> <span style="color: #008000">str</span>(<span style="color: #008000">iter</span>) <span style="color: #666666">+</span><span style="color: #BA2121">&#39; iterations&#39;</span>)
    <span style="color: #008000; font-weight: bold">return</span> x
</pre></div>
<p>
The iterative method can be appealing if we do not need a high accuracy, we can choose to stop whenever \( |\mathbf{x}^{k+1}-\mathbf{x}^k| \) is small enough. For the direct method we have to follow through all the way.
<div class="alert alert-block alert-success alert-text-normal"><b>Convergence.</b>
The Jacobi method converges if the matrix \( \mathbf{A} \) is strictly diagonally dominant. Strictly diagonally dominant means that the absolute value of each entry on the diagonal is greater than the sum of the absolute values of the other entries in the same row, i.e if \( |a_{00}|>|a_{01}+a_{02}+\cdots| \). In general it can be shown that a iterative scheme \( \mathbf{x}^{k+1}=\mathbf{P}\cdot \mathbf{x}^k+\mathbf{q} \) is convergent <em>if and only if</em> every eigenvalue, \( \lambda \), of \( \mathbf{P} \) satisfies \( |\lambda| < 1 \), i.e. the <em>spectral radius</em> \( \rho(\mathbf{P}) < 1 \).
</div>


<h2 id="___sec7" class="anchor">The Gauss-Seidel method </h2>
It is tempting in equation \eqref{eq:lin:jc3a} to use our estimate of \( x_0^{k+1} \) in the next equation, equation \eqref{eq:lin:jc3b}, instead of \( x_0^k \). After all our estimate \( x_0^{k+1} \) is an <em>improved</em> estimate. This is actually the Gauss-Seidel method. This method also has the advantage that if there are memory issues, one can overwrite the old value of \( x_i^k \). Usually the Gauss-Seidel method converges faster, but not always. A plus for the Jacobi method is that is can be  parallelised, as the calculations is only dependent on the old values and do not require information about the new values as for the Gauss Seidel method. Below is a Python implementation of the Gauss-Seidel method

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">solve_GS</span>(A,b,x<span style="color: #666666">=</span>np<span style="color: #666666">.</span>zeros(<span style="color: #008000">len</span>(b)),max_iter<span style="color: #666666">=1000</span>,EPS<span style="color: #666666">=1e-6</span>):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Solves the linear system Ax=b using the Gauss-Seidel method, stops if</span>
<span style="color: #BA2121; font-style: italic">    solution is not found after max_iter or if solution changes less </span>
<span style="color: #BA2121; font-style: italic">    than EPS</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    D<span style="color: #666666">=</span>np<span style="color: #666666">.</span>diag(A)
    R<span style="color: #666666">=</span>A<span style="color: #666666">-</span>np<span style="color: #666666">.</span>diag(D)
    eps<span style="color: #666666">=1</span>
    <span style="color: #008000">iter</span><span style="color: #666666">=0</span>
    <span style="color: #008000; font-weight: bold">while</span>(eps<span style="color: #666666">&gt;</span>EPS <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #008000">iter</span><span style="color: #666666">&lt;</span>max_iter):
        <span style="color: #008000">iter</span><span style="color: #666666">+=1</span>
        eps<span style="color: #666666">=0.</span>
        <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(x)):
            tmp<span style="color: #666666">=</span>x[i]
            x[i]<span style="color: #666666">=</span>w<span style="color: #666666">*</span>(b[i]<span style="color: #666666">-</span> np<span style="color: #666666">.</span>dot(R[i,:],x))<span style="color: #666666">/</span>D[i]
            eps<span style="color: #666666">+=</span>np<span style="color: #666666">.</span>abs(tmp<span style="color: #666666">-</span>x[i])
    <span style="color: #008000">print</span>(<span style="color: #BA2121">&#39;found solution after &#39;</span> <span style="color: #666666">+</span> <span style="color: #008000">str</span>(<span style="color: #008000">iter</span>) <span style="color: #666666">+</span><span style="color: #BA2121">&#39; iterations&#39;</span>)
    <span style="color: #008000; font-weight: bold">return</span> x
</pre></div>

<h1 id="___sec8" class="anchor">Example: Linear regression </h1>
In the previous section, we considered a system of \( N \) equations and \( N \) unknown (\( x_0, x_1,\ldots, x_N \)). In general we might have more equations than unknowns or more unknowns than equations. An example of the former is linear regression, we might have many data points and we would like to fit a line through the points. How do you fit a single lines to more than two points that does not line on the same line? One way to do it is to minimize the distance from the line to the points, as illustrated in figure <a href="#fig:lin:reg">1</a>.

<p>
<center> <!-- figure label: --> <div id="fig:lin:reg"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 1:  Linear regression by minimizing the total distance to all the points.  <!-- caption label: fig:lin:reg --> </p></center>
<p><img src="fig-lin/reg.png" align="bottom" width=800></p>
</center>

<p>
Mathematically we can express the distance between a data point \( (x_i,y_i) \) and the line \( f(x) \) as \( y_i-f(x_i) \). Note that this difference can be negative or positive depending if the data point lies below or above the line. We can then take the absolute value of all the distances, and try to minimize them. When we minimize something we take the derivative of the expression and put it equal to zero.  As you might remember from Calculus it is extremely hard to work with the derivative of the absolute value, because it is discontinuous. A much better approach is to square each distance and sum them:
$$
\begin{equation}
S=\sum_{i=0}^{N-1}(y_i-f(x_i))^2=\sum_{i=0}^{N-1}(y_i-a_0-a_1x_i)^2.
\tag{15}
\end{equation}
$$

(For the example in figure <a href="#fig:lin:reg">1</a>, \( N=5 \).) This is the idea behind <em>least square</em>, and linear regression. One thing you should be aware of is that points lying far from the line will contribute more to equation <a href="#mjx-eqn-15">(15)</a>. The underlying assumption is that each data point provides equally precise information about the process, this is often not the case. When analyzing experimental data, there may be points deviating from the expected behaviour, it is then important to investigate if these points are more affected by measurements errors than the others. If that is the case one should give them less weight in the least square estimate, by extending the formula above:
$$
\begin{equation}
S=\sum_{i=0}^{N-1}\omega_i(y_i-f(x_i))^2=\sum_{i=0}^3\omega_i(y_i-a_0-a_1x_i)^2,
\tag{16}
\end{equation}
$$

\( \omega_i \) is a weight factor.

<h2 id="___sec9" class="anchor">Solving least square, using algebraic equations </h2>
Let us continue with equation <a href="#mjx-eqn-15">(15)</a>, the algebraic solution is to simply find the value of \( a_0 \) and \( a_1 \) that minimizes \( S \):
$$
\begin{align}
\frac{\partial S}{\partial a_0} &=-2\sum_{i=0}^{N-1}(y_i-a_0-a_1x_i)=0,
\tag{17} \\ 
\frac{\partial S}{\partial a_1} &=-2\sum_{i=0}^{N-1}(y_i-a_0-a_1x_i)x_i=0.
\tag{18}
\end{align}
$$

Defining the mean value as \( \overline{x}=\sum_ix_i/N \) and \( \overline{y}=\sum_iy_i/N \), we can write equation <a href="#mjx-eqn-17">(17)</a> and <a href="#mjx-eqn-18">(18)</a>  as:
$$
\begin{align}
\sum_{i=0}^{N-1}(y_i-a_0-a_1x_i)&=N\overline{y}-a_0N-a_1N\overline{x}=0,
\tag{19} \\ 
\sum_{i=0}^{N-1}(y_i-a_0-a_1x_i)x_i&=\sum_iy_ix_i-a_0N\overline{x}-a_1\sum_ix_ix_i=0.
\tag{20}
\end{align}
$$

Solving equation <a href="#mjx-eqn-19">(19)</a> with respect to \( a_0 \), and inserting the expression into equation <a href="#mjx-eqn-20">(20)</a>, we find:
$$
\begin{align}
a_0&=\overline{y}-a_1\overline{x},label{eq:lin:ls1c} \\ 
a_1&=\frac{\sum_iy_ix_i-N\overline{x}\overline{y}}{\sum_ix_i^2-N\overline{x}^2}
=\frac{\sum_i(x_i-\overline{x})(y_i-\overline{y})}{\sum_i(x_i-\overline{x})^2}.
\tag{21}
\end{align}
$$

We leave it as an exercise to show the last expression for \( a_1 \).  
Clearly the equation <a href="#mjx-eqn-21">(21)</a> above will in most cases have
a solution. But in addition to a solution, it would be good to have an
idea of the goodness of the fit. Intuitively it make sense to add all
the distances (residuals) \( d_i \) in figure <a href="#fig:lin:reg">1</a>. This is
basically what is done when calculating \( R^2 \) (R-squared). However, we
would also like to compare the \( R^2 \) between different
datasets. Therefor we need to normalize the sum of residuals, and
therefore the following form of the \( R^2 \) is used:
$$
\begin{equation}
R^2=1-\frac{\sum_{i=0}^{N-1}(y_i-f(x_i))^2}{\sum_{i=0}^{N-1}(y_i-\overline{y})^2}.
\tag{22}
\end{equation}
$$

In python we can implement equation \eqref{eq:lin:ls1c}, <a href="#mjx-eqn-21">(21)</a> and <a href="#mjx-eqn-22">(22)</a> as:
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">OLS</span>(x, y): 
    <span style="color: #408080; font-style: italic"># returns regression coefficients</span>
    <span style="color: #408080; font-style: italic"># in ordinary least square</span>
    <span style="color: #408080; font-style: italic"># x: observations</span>
    <span style="color: #408080; font-style: italic"># y: response</span>
    <span style="color: #408080; font-style: italic"># R^2: R-squared</span>
    n <span style="color: #666666">=</span> np<span style="color: #666666">.</span>size(x) <span style="color: #408080; font-style: italic"># number of data points </span>
  
    <span style="color: #408080; font-style: italic"># mean of x and y vector </span>
    m_x, m_y <span style="color: #666666">=</span> np<span style="color: #666666">.</span>mean(x), np<span style="color: #666666">.</span>mean(y) 
  
    <span style="color: #408080; font-style: italic"># calculating cross-deviation and deviation about x </span>
    SS_xy <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sum(y<span style="color: #666666">*</span>x) <span style="color: #666666">-</span> n<span style="color: #666666">*</span>m_y<span style="color: #666666">*</span>m_x 
    SS_xx <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sum(x<span style="color: #666666">*</span>x) <span style="color: #666666">-</span> n<span style="color: #666666">*</span>m_x<span style="color: #666666">*</span>m_x 
  
    <span style="color: #408080; font-style: italic"># calculating regression coefficients </span>
    b_1 <span style="color: #666666">=</span> SS_xy <span style="color: #666666">/</span> SS_xx 
    b_0 <span style="color: #666666">=</span> m_y <span style="color: #666666">-</span> b_1<span style="color: #666666">*</span>m_x

    <span style="color: #408080; font-style: italic">#R^2</span>
    y_pred <span style="color: #666666">=</span> b_0 <span style="color: #666666">+</span> b_1<span style="color: #666666">*</span>x
    S_yy   <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sum(y<span style="color: #666666">*</span>y) <span style="color: #666666">-</span> n<span style="color: #666666">*</span>m_y<span style="color: #666666">*</span>m_y
    y_res  <span style="color: #666666">=</span> y<span style="color: #666666">-</span>y_pred  
    S_res  <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sum(y_res<span style="color: #666666">*</span>y_res)
  
    <span style="color: #008000; font-weight: bold">return</span>(b_0, b_1,<span style="color: #666666">1-</span>S_res<span style="color: #666666">/</span>S_yy)
</pre></div>

<h2 id="___sec10" class="anchor">Least square as a linear algebra problem </h2>
It turns out that the least square problem can be formulated as a
matrix problem. (Two great explanations see <a href="https://medium.com/@andrew.chamberlain/the-linear-algebra-view-of-least-squares-regression-f67044b7f39b" target="_self">linear regression by
matrices</a>,
and
<a href="https://medium.com/@andrew.chamberlain/a-more-elegant-view-of-r-squared-a0a14c177dc3" target="_self">$R^2$-squared</a>.)
If we define a matrix \( \mathbf{X} \) containing the observations \( x_i \)
as:
$$
\begin{align}
\mathbf{X} &=
\begin{pmatrix}
1&x_0\\ 
1&x_1\\ 
\vdots&\vdots\\ 
1&x_{N-1}
\end{pmatrix}.
\tag{23}
\end{align}$$

We introduce a vector containing all the response \( \mathbf{y} \), and the
regression coefficients \( \mathbf{a}=(a_0,a_1) \). Then we can write
equation <a href="#mjx-eqn-16">(16)</a> as a matrix equation:
$$
\begin{equation}
S=(\mathbf{y}-\mathbf{X\cdot a})^T(\mathbf{y}-\mathbf{X\cdot a}).
\tag{24}
\end{equation}
$$

<em>Note that this equation can easily be extended to more than one
observation variable \( x_i \)</em>. By simply differentiating equation
<a href="#mjx-eqn-24">(24)</a> with respect to \( \mathbf{a} \), we can show that
the derivative has a minimum when (see proof below):
$$
\begin{equation}
\mathbf{X}^T\mathbf{X a}=\mathbf{X}^T\mathbf{y}
\tag{25}
\end{equation}
$$

Below is a python implementation of equation <a href="#mjx-eqn-25">(25)</a>.
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">OLSM</span>(x, y): 
    <span style="color: #408080; font-style: italic"># returns regression coefficients</span>
    <span style="color: #408080; font-style: italic"># in ordinary least square using solve function</span>
    <span style="color: #408080; font-style: italic"># x: observations</span>
    <span style="color: #408080; font-style: italic"># y: response</span>

    XT <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array([np<span style="color: #666666">.</span>ones(<span style="color: #008000">len</span>(x)),x],<span style="color: #008000">float</span>)
    X  <span style="color: #666666">=</span> np<span style="color: #666666">.</span>transpose(XT)
    B <span style="color: #666666">=</span> np<span style="color: #666666">.</span>dot(XT,X)
    C <span style="color: #666666">=</span> np<span style="color: #666666">.</span>dot(XT,y)
    <span style="color: #008000; font-weight: bold">return</span> solve(B,C)
</pre></div>

<h2 id="___sec11" class="anchor">Working with matrices on component form </h2>
Whenever you want to do some manipulation with matrices, it is very useful to simply write them on component form. If we multiply two matrices \( \mathbf{A} \) and \( \mathbf{B} \) to form a new matrix \( \mathbf{C} \), the components of the new matrix is simply \( \mathbf{C}_{ij}=\sum_k\mathbf{A}_{ik}\mathbf{B}_{kj} \). The strength of doing this is that the elements of a matrix, e.g. \( \mathbf{A}_{ik} \) are <em>numbers</em>, and we can move them around. Proving that e.g. \( (\mathbf{A}\mathbf{B})^T=\mathbf{B}^T\mathbf{A}^T \) is straight forward using the component form. The transpose of a matrix is simply to exchange columns and rows, hence \( \mathbf{C}_{ij}^T=\mathbf{C}_{ji} \)
$$
\begin{equation}
\mathbf{C}_{ij}^T=\mathbf{C}_{ji}=\sum_k\mathbf{A}_{jk}\mathbf{B}_{ki}=\sum_k\mathbf{B}^T_{ik}\mathbf{A}^T_{kj}
=(\mathbf{B}^T\mathbf{A}^T)_{ij},
\tag{26}
\end{equation}
$$

thus \( \mathbf{C}^T=\mathbf{B}^T\mathbf{A}^T \). To derive equation <a href="#mjx-eqn-25">(25)</a>, we need to take the derivative of equation <a href="#mjx-eqn-25">(25)</a> with respect to \( \mathbf{a} \).
What we mean by this is that we want to evaluate \( \partial S/\partial a_k \) for all the components of \( \mathbf{a} \).
A useful rule is \( \partial a_i/\partial a_k=\delta_{ik} \), where \( \delta_{ik} \) is the Kronecker delta, it takes the value of one if \( i=k \) and zero otherwise. We can write \( S=\mathbf{y}^T\mathbf{y}-\mathbf{y}\mathbf{X\cdot a}
-(\mathbf{X\cdot a})^T\mathbf{y}-(\mathbf{X\cdot a})^T\mathbf{X\cdot a} \). All terms that do not contain \( \mathbf{a} \) are zero, thus we only need to evaluate the following terms
$$
\begin{align}
\frac{\partial}{a_k}(\mathbf{X\cdot a})^T\mathbf{y} &=\frac{\partial}{a_k}(\mathbf{a}^T\cdot \mathbf{X}^T\mathbf{y})=\frac{\partial}{a_k}\sum_{ij}\mathbf{a}^T_i\mathbf{X}^T_{ij}\mathbf{y}_j
=\sum_{ij}\delta_{ik}\mathbf{X}^T_{ij}\mathbf{y}_j\no
\tag{27}\\ 
&=\sum_{j}\mathbf{X}^T_{kj}\mathbf{y}_j=\mathbf{X}^T\mathbf{y} 
\tag{28}\\ 
\frac{\partial}{a_k}\mathbf{y}^T\mathbf{X\cdot a}&=\frac{\partial}{a_k}\sum_{ij}\mathbf{y}^T_i\mathbf{X}_{ij}\mathbf{a}_j
=\sum_{ij}\mathbf{y}^T_i\mathbf{X}_{ij}\delta_{jk}=\sum_{j}\mathbf{y}^T_{i}\mathbf{X}_{ik}\no
\tag{29}\\ 
&=\sum_{j}\mathbf{y}^T_{i}\mathbf{X}^T_{ki}=\mathbf{X}^T\mathbf{y} 
\tag{30}\\ 
\frac{\partial}{a_k} (\mathbf{X\cdot a})^T\mathbf{X\cdot a}&=
\frac{\partial}{a_k}\sum_{ijl} \mathbf{a}^T_i\mathbf{X}^T_{ij}\mathbf{X}_{jl}\mathbf{a}_l=
\sum_{ijl}(\delta_{ik}\mathbf{X}^T_{ij}\mathbf{X}_{jl}\mathbf{a}_l+\mathbf{a}^T_i\mathbf{X}^T_{ij}\mathbf{X}_{jl}\delta_{lk})\no
\tag{31}\\&=\sum_{jl}\mathbf{X}^T_{kj}\mathbf{X}_{jl}
\mathbf{a}_l+\sum_{ij}\mathbf{a}^T_i\mathbf{X}^T_{ij}\mathbf{X}_{jk}\no
\tag{32}\\ 
&=\mathbf{X}^T\mathbf{X}\mathbf{a}+\sum_{ij}\mathbf{X}^T_{kj}\mathbf{X}_{ji}\mathbf{a}_i
= 2\mathbf{X}^T\mathbf{X}\mathbf{a}.
\label{}
\end{align}
$$

It then follows that \( \partial S/\partial \mathbf{a} = 0 \) when
$$
\begin{equation}
\mathbf{X}^T\mathbf{X a}=\mathbf{X}^T\mathbf{y}.
\tag{33}
\end{equation}
$$

<h1 id="___sec12" class="anchor">Sparse matrices and Thomas algorithm </h1>
In many practical examples, such as solving partial differential
equations the matrices could be quite large and also contain a lot of
zeros. A very important class of such matrices are <em>banded matrices</em>
this is a type of <em>sparse matrices</em> containing a lot of zero elements,
and the non-zero elements are confined to diagonal bands. In the
following we will focus on one important type of sparse matrix the
tridiagonal. In the next section we will show how it enters naturally
in solving the heat equation. It turns out that solving banded
matrices is quite simple, and can be coded quite efficiently. As with
the Gauss-Jordan example, lets consider a concrete example:
$$
\begin{align}
&\left(
\begin{array}{ccccc|c}
b_0&c_0&0&0&0&r_0\\ 
a_1&b_1&c_1&0&0&r_1\\ 
0&a_2&b_2&c_2&0&r_2\\ 
0& 0&a_3&b_3&c_3&r_3\\ 
0& 0& 0&a_4&b_4&r_4
\end{array}
\right)
\tag{34}
\end{align}$$

The right hand side is represented with \( r_i \). The first Gauss-Jordan
step is simply to divide by \( b_0 \), then we multiply with \( -a_1 \) and
add to second row:
$$
\begin{align}
\to \left(
\begin{array}{ccccc|c}
1&c_0^\prime&0&0&0&r_0^\prime\\ 
0&b_1-a_1c_0^\prime&c_1&0&0&r_1-a_0r_0^\prime\\ 
0&a_2&b_2&c_2&0&r_2\\ 
0& 0&a_3&b_3&c_3&r_3\\ 
0& 0& 0&a_4&b_4&r_4
\end{array}
\right),
\tag{35}
\end{align}$$

Note that we have introduced some new symbols to simplify the
notation: \( c_0^\prime=c_0/b_0 \) and \( r_0^\prime=r_0/b_0 \). Then we
divide by \( b_1-a_1c_0^\prime \):
$$
\begin{align}
&\left(
\begin{array}{ccccc|c}
1&c_0^\prime&0&0&0&r_0^\prime\\ 
0&1&c_1^\prime&0&0&r_1^\prime\\ 
0&a_2&b_2&c_2&0&r_2\\ 
0& 0&a_3&b_3&c_3&r_3\\ 
0& 0& 0&a_4&b_4&r_4
\end{array}
\right),
\tag{36}
\end{align}$$

where \( c_1^\prime=c_1/(b_1-a_1c_0^\prime) \) and
\( r_1^\prime=(r_1-a_0r_0^\prime)/(b_1-a_1c_0^\prime) \). If you continue
in this manner, you can easily convince yourself that to transform a
tridiagonal matrix to the following form:
$$
\begin{align}
\to \left(
\begin{array}{ccccc|c}
1&c_0^\prime&0&0&0&r_0^\prime\\ 
0&1&c_1^\prime&0&0&r_1^\prime\\ 
0&0&1&c_2^\prime&0&r_2^\prime\\ 
0& 0&0&1&c_3^\prime&r_3^\prime\\ 
0& 0& 0&0&1&r_4^\prime
\end{array}
\right),
\tag{37}
\end{align}$$

where:
$$
\begin{align}
c_0^\prime =\frac{c_0}{b_0} \qquad &r_0^\prime={r_0}{b_0}
\tag{38} \\ 
c_i^\prime
=\frac{c_i}{b_i-a_ic_{i-1}^\prime}\qquad
&r_i^\prime=\frac{r_i-a_ir_{i-1}^\prime}{b_i-a_ic_{i-1}^\prime}
\quad\text{, for }i=1,2,\ldots,N-1label{eq:lin:thi} 
\end{align}
$$

Note that we where able to reduce the tridiagonal matrix to an <em>upper
triangular</em> matrix in only <em>one</em> Gauss-Jordan step. This equation can
readily be solved using back-substitution, which can also be
simplified as there are a lot of zeros in the upper part. Let us
denote the unknowns \( x_i \) as we did for the Gauss-Jordan case, now we
can find the solution as follows:
$$
\begin{align}
x_{N-1} & = r_{N-1}^\prime \tag{39} \\ 
x_i     & = r_i^\prime-x_{i+1}c_i^\prime\quad\text{, for } i=N-2,N-3,\ldots,0
\tag{40}
\end{align}
$$

Equation <a href="#mjx-eqn-38">(38)</a>, \eqref{eq:lin:thi}, <a href="#mjx-eqn-39">(39)</a>
and <a href="#mjx-eqn-40">(40)</a> is known as the Thomas algorithm after
Llewellyn Thomas. 
<div class="alert alert-block alert-success alert-text-normal"><b>Notice.</b>
Clearly tridiagonal matrices can be solved much more efficiently with
the Thomas algorithm than
using a standard library, such as LU-decomposition. This is
because the solution method takes advantages of the <em>symmetry</em> of the
problem. We will not show it here, but it can be shown that the Thomas
algorithm is stable whenever \( |b_i|\ge |a_i|+|c_i| \). If the algorithm
fails, an advice is first to use the standard <code>solve</code> function in
python. If this gives a solution, then <em>pivoting</em> combined with the
Thomas algorithm might do the trick.
</div>


<h1 id="___sec13" class="anchor">Example: Solving the heat equation using linear algebra </h1>

<p>
<!-- --- begin exercise --- -->

<h2 id="___sec14" class="anchor">Exercise 1: Conservation Equation or the Continuity Equation </h2>

<p>
<center> <!-- figure label: --> <div id="fig:nlin:heat"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 2:  Conservation of energy and the continuity equation.  <!-- caption label: fig:nlin:heat --> </p></center>
<p><img src="fig-lin/heat.png" align="bottom" width=700></p>
</center>

<p>
In figure <a href="#fig:nlin:heat">2</a>, the continuity equation is derived for
heat flow.
In the case of heat exchange for a solid, we can show
that it can be written:
$$
\begin{equation}
\frac{d^2T}{dx^2}+\frac{\dot{\sigma}}{k}=\frac{\rho c_p}{k}\frac{dT}{dt},
\tag{41}
\end{equation}
$$

where \( \dot{\sigma} \) is the rate of heat generation in the solid. This
equation can be used as a starting point for many interesting
models. In this exercise we will investigate the <em>steady state</em>
solution, <em>steady state</em> is just a fancy way of expressing that we
want the solution that <em>does not change with time</em>. This is achieved
by ignoring the derivative with respect to time in equation
<a href="#mjx-eqn-41">(41)</a>. We want to study a system with size \( L \), and is
it good practice to introduce a dimensionless variable: \( y=x/L \). 
Equation <a href="#mjx-eqn-41">(41)</a> can now be written:
$$
\begin{equation}
\frac{d^2T }{dy^2}+\frac{\dot{\sigma}L^2}{k}=0
\tag{42}
\end{equation}
$$

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="___sec15" class="anchor">Exercise 2: Curing of Concrete and Matrix Formulation </h2>

<p>
Curing of concrete is one particular example that we can investigate
with equation <a href="#mjx-eqn-42">(42)</a>. When concrete is curing, there are
a lot of chemical reactions happening, these reactions generate
heat. This is a known issue, and if the temperature rises too much 
compared to the surroundings, the concrete may fracture.  In the
following we will, for simplicity, assume that the rate of heat
generated during curing is constant, $\dot{\sigma}=$100 W/m$^3$. The
left end (at \( x=0 \)) is insulated, meaning that there is no flow of
heat over that boundary, hence \( dT/dx=0 \) at \( x=0 \). On the right hand
side the temperature is kept constant, \( x(L)=y(1)=T_1 \), assumed to be
equal to the ambient temperature of $T_1=25^\circ$C.  The concrete
thermal conductivity is assumed to be \( k=1.65 \) W/m$^\circ$C.

<p>
We leave it as an exercise to show that the analytical solution to equation <a href="#mjx-eqn-42">(42)</a> in this case is:
$$
\begin{equation}
T(y)=\frac{\dot{\sigma}L^2}{2k}(1-y^2)+T_1.
\tag{43}
\end{equation}
$$

In order to solve equation <a href="#mjx-eqn-42">(42)</a> numerically, we need to discretize
it.
We replace the second derivative with
\( dT/dy^2=(T(y+dy)+T(y-dy)-2T(y))/dy^2 \). Equation <a href="#mjx-eqn-41">(41)</a> can now be written:
$$
\begin{equation}
T_{i+1}+T_{i-1}-2T_i=-h^2\beta,
\tag{44}
\end{equation}
$$

where \( \beta=\dot{\sigma}L^2/k \).

<p>
<center> <!-- figure label: --> <div id="fig:nlin:hgrid"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 3:  Finite difference grid for \( N=4 \).  <!-- caption label: fig:nlin:hgrid --> </p></center>
<p><img src="fig-lin/heat_grid.png" align="bottom" width=200></p>
</center>

<p>
In figure <a href="#fig:nlin:hgrid">3</a>, the finite difference grid is shown for
\( N=4 \). Let us write down equation <a href="#mjx-eqn-44">(44)</a> for each grid
node to see how the implementation is done in practice:
$$
\begin{align}
T_{-1}+T_1-2T_0 &=-h^2\beta,\no
\tag{45}\\ 
T_{0}+T_2-2T_1 &=-h^2\beta,\no
\tag{46}\\ 
T_{1}+T_3-2T_2 &=-h^2\beta,\no
\tag{47}\\ 
T_{2}+T_4-2T_3 &=-h^2\beta.\no
\tag{48}\\ 
\tag{49}
\end{align}
$$

The tricky part is now to introduce the boundary conditions. The right
hand side is easy, because here the temperature is \( T_4=25 \). However,
we see that \( T_{-1} \) enters and we have no value for this node. The
boundary condition on the left hand side is \( dT/dy=0 \), by using the
central difference for the derivative allows us to write:
$$
\begin{equation}
\left.\frac{dT}{dy}\right|_{y=0}=\frac{T_{-1}-T_1}{2h}=0,
\tag{50}
\end{equation}
$$

hence \( T_{-1}=T_1 \). Thus the final set of equations are:
$$
\begin{align}
2T_1-2T_0 &=-h^2\beta,\no
\tag{51}\\ 
T_{0}+T_2-2T_1 &=-h^2\beta,\no
\tag{52}\\ 
T_{1}+T_3-2T_2 &=-h^2\beta,\no
\tag{53}\\ 
T_{2}+25-2T_3 &=-h^2\beta,\no
\tag{54}\\ 
\tag{55}
\end{align}
$$

or in matrix form:
$$
\begin{align}
\left(
\begin{array}{cccc}
-2&2&0&0\\ 
1&-2&1&0\\ 
0&1&-2&1\\ 
0&0&1&-2\\ 
\end{array}
\right)
\left(
\begin{array}{c}
T_0\\ 
T_1\\ 
T_2\\ 
T_3\\ 
\end{array}
\right)
=
\left(
\begin{array}{c}
-h^2\beta\\ 
-h^2\beta\\ 
-h^2\beta\\ 
-h^2\beta-25\\ 
\end{array}
\right).
\tag{56}
\end{align}
\tag{57}$$

Note that it is now easy to increase \( N \) as it is only the boundaries
that requires special attention.

<ul>
<li> Solve the set of equations using <a href="https://numpy.org/doc/stable/reference/generated/numpy.linalg.solve.html" target="_self"><tt>numpy.linalg.solve</tt></a>.</li>
</ul>

The correct solution is \( L=1 \) m, and \( h=1/4 \), is: \( [T_0,T_1.T_2,T_3]=[55.3030303 , 53.40909091, 47.72727273, 38.25757576] \).

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_2_1" style="font-size: 80%;"></a>
<a href="#exer_2_1" data-toggle="collapse">
<b>Solution.</b>
</a>
<div class="collapse-group">
<p><div class="collapse" id="exer_2_1">

<p>
<div class="alert alert-block alert-success alert-text-normal"><b>Notice.</b>
The solution below implements equation <a href="#mjx-eqn-57">(57)</a> using sparse matrices, and the standard Numpy <code>solve</code> function. You can use the <code>%timeit</code> magic command in Ipython and Jupyter notebooks to test the efficiency.
</div>


<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #408080; font-style: italic">#%matplotlib inline</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">scipy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sc</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">scipy.sparse.linalg</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy.linalg</span> <span style="color: #008000; font-weight: bold">import</span> solve
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>

<span style="color: #408080; font-style: italic"># Set simulation parameters</span>
h <span style="color: #666666">=</span> <span style="color: #666666">0.25</span>             <span style="color: #408080; font-style: italic"># element size</span>
L <span style="color: #666666">=</span> <span style="color: #666666">1.0</span>              <span style="color: #408080; font-style: italic"># length of domain</span>
n <span style="color: #666666">=</span> <span style="color: #008000">int</span>(<span style="color: #008000">round</span>(L<span style="color: #666666">/</span>h))  <span style="color: #408080; font-style: italic"># number of unknowns </span>
x<span style="color: #666666">=</span>np<span style="color: #666666">.</span>arange(n<span style="color: #666666">+1</span>)<span style="color: #666666">*</span>h   <span style="color: #408080; font-style: italic"># includes right bc </span>
T1<span style="color: #666666">=25</span>
sigma <span style="color: #666666">=</span> <span style="color: #666666">100*</span>L<span style="color: #666666">**2/1.65</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">tri_diag</span>(a, b, c, k1<span style="color: #666666">=-1</span>, k2<span style="color: #666666">=0</span>, k3<span style="color: #666666">=1</span>):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot; a,b,c diagonal terms &quot;&quot;&quot;</span>
    <span style="color: #008000; font-weight: bold">return</span> np<span style="color: #666666">.</span>diag(a, k1) <span style="color: #666666">+</span> np<span style="color: #666666">.</span>diag(b, k2) <span style="color: #666666">+</span> np<span style="color: #666666">.</span>diag(c, k3)

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">analytical</span>(sigma,x):
    <span style="color: #008000; font-weight: bold">return</span> sigma<span style="color: #666666">*</span>(<span style="color: #666666">1-</span>x<span style="color: #666666">*</span>x)<span style="color: #666666">/2+</span>T1

<span style="color: #408080; font-style: italic">#Create matrix for linalg solver</span>
a<span style="color: #666666">=</span>np<span style="color: #666666">.</span>ones(n<span style="color: #666666">-1</span>)
b<span style="color: #666666">=-</span>np<span style="color: #666666">.</span>ones(n)<span style="color: #666666">*2</span>
c<span style="color: #666666">=</span>np<span style="color: #666666">.</span>ones(n<span style="color: #666666">-1</span>)
<span style="color: #408080; font-style: italic">#Create matrix for sparse solver</span>
diagonals<span style="color: #666666">=</span>np<span style="color: #666666">.</span>zeros((<span style="color: #666666">3</span>,n))
diagonals[<span style="color: #666666">0</span>,:]<span style="color: #666666">=</span> <span style="color: #666666">1</span>
diagonals[<span style="color: #666666">1</span>,:]<span style="color: #666666">=</span> <span style="color: #666666">-2</span>  
diagonals[<span style="color: #666666">2</span>,:]<span style="color: #666666">=</span> <span style="color: #666666">1</span>

<span style="color: #408080; font-style: italic"># rhs vector</span>
d<span style="color: #666666">=</span>np<span style="color: #666666">.</span>repeat(<span style="color: #666666">-</span>h<span style="color: #666666">*</span>h<span style="color: #666666">*</span>sigma,n)

<span style="color: #408080; font-style: italic">#----boundary conditions ------</span>
<span style="color: #408080; font-style: italic">#lhs - no flux of heat</span>
diagonals[<span style="color: #666666">2</span>,<span style="color: #666666">1</span>]<span style="color: #666666">=</span> <span style="color: #666666">2</span>
c[<span style="color: #666666">0</span>]<span style="color: #666666">=2</span>
<span style="color: #408080; font-style: italic">#rhs - constant temperature</span>
d[n<span style="color: #666666">-1</span>]<span style="color: #666666">=</span>d[n<span style="color: #666666">-1</span>]<span style="color: #666666">-</span>T1
<span style="color: #408080; font-style: italic">#------------------------------</span>

A<span style="color: #666666">=</span>tri_diag(a,b,c)
A_sparse <span style="color: #666666">=</span> sc<span style="color: #666666">.</span>sparse<span style="color: #666666">.</span>spdiags(diagonals, [<span style="color: #666666">-1</span>,<span style="color: #666666">0</span>,<span style="color: #666666">1</span>], n, n,<span style="color: #008000">format</span><span style="color: #666666">=</span><span style="color: #BA2121">&#39;csc&#39;</span>) 
<span style="color: #408080; font-style: italic"># to view matrix</span>
<span style="color: #008000">print</span>(A_sparse<span style="color: #666666">.</span>todense())
<span style="color: #408080; font-style: italic">#Solve linear problems</span>
Ta <span style="color: #666666">=</span> solve(A,d,)
Tb <span style="color: #666666">=</span> sc<span style="color: #666666">.</span>sparse<span style="color: #666666">.</span>linalg<span style="color: #666666">.</span>spsolve(A_sparse,d)
<span style="color: #408080; font-style: italic">#Add right boundary node</span>
Ta<span style="color: #666666">=</span>np<span style="color: #666666">.</span>append(Ta,T1)
Tb<span style="color: #666666">=</span>np<span style="color: #666666">.</span>append(Tb,T1)
<span style="color: #408080; font-style: italic">#uncomment to test efficiency</span>
<span style="color: #408080; font-style: italic">#%timeit sc.sparse.linalg.spsolve(A_sparse,d)</span>
<span style="color: #408080; font-style: italic">#%timeit solve(A,d,)</span>

<span style="color: #408080; font-style: italic"># Plot solutions</span>
plt<span style="color: #666666">.</span>plot(x,Ta,x,Tb,<span style="color: #BA2121">&#39;-.&#39;</span>,x,analytical(sigma,x),<span style="color: #BA2121">&#39;:&#39;</span>, lw<span style="color: #666666">=3</span>)
plt<span style="color: #666666">.</span>xlabel(<span style="color: #BA2121">&quot;Dimensionless length&quot;</span>)
plt<span style="color: #666666">.</span>ylabel(<span style="color: #BA2121">r&quot;Temperature [$^\circ$C]&quot;</span>)
plt<span style="color: #666666">.</span>xlim(<span style="color: #666666">0</span>,<span style="color: #666666">1</span>)
plt<span style="color: #666666">.</span>ylim(T1<span style="color: #666666">-1</span>)
plt<span style="color: #666666">.</span>legend([<span style="color: #BA2121">&#39;sparse&#39;</span>,<span style="color: #BA2121">&#39;linalg&#39;</span>,<span style="color: #BA2121">&#39;analytical&#39;</span>])
plt<span style="color: #666666">.</span>grid()
plt<span style="color: #666666">.</span>show()
</pre></div>
<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<!-- --- end exercise --- -->

<h1 id="___sec16" class="anchor">References </h1>

<p>
<!-- begin bibliography -->

<ol>
 <li> <div id="press2007"></div> <b>W. H. Press, S. A. Teukolsky, W. T. Vetterling and B. P. Flannery</b>. 
    <em>Numerical Recipes 3rd Edition: the Art of Scientific Computing</em>,
    3 edition,
    Cambridge University Press,
    2007.</li>
 <li> <div id="trefethen1997"></div> <b>L. N. Trefethen and D. B. III</b>. 
    <em>Numerical Linear Algebra</em>,
    SIAM,
    1997.</li>
 <li> <div id="stoer2013"></div> <b>J. Stoer and R. Bulirsch</b>. 
    <em>Introduction to Numerical Analysis</em>,
    Springer Science &amp; Business Media,
    2013.</li>
 <li> <div id="strang2019"></div> <b>G. Strang</b>. 
    <em>Linear Algebra and Learning From Data</em>,
    Wellesley-Cambridge Press,
    2019.</li>
 <li> <div id="press2001"></div> <b>W. H. Press, W. T. Vetterling, S. A. Teukolsky and B. P. Flannery</b>. 
    <em>Numerical Recipes in C++: the Art of Scientific Computing</em>,
    2nd edition,
    Cambridge University Press,
    2002.</li>
</ol>

<!-- end bibliography -->

<p>
<!-- navigation buttons at the bottom of the page -->
<ul class="pager">
</ul>
<!-- ------------------- end of main content --------------- -->

</div>  <!-- end container -->
<!-- include javascript, jQuery *first* -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="https://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>

<!-- Bootstrap footer
<footer>
<a href="http://..."><img width="250" align=right src="http://..."></a>
</footer>
-->


</body>
</html>
    

